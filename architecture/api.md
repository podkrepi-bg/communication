# Технически изисквания

## Въведение

Изисквания към техническата разработка на open-source проект Подкрепи.бг

## Обхват

Да се създаде **безплатна** и **напълно прозрачна** онлайн платформа за дарения, която да може да се ползва свободно от граждани и организации.

## Изисквания

### Публичност

* Кодът на проекта трябва да е публичен и това да не компрометира сигурността
* Да има публична и лична част на платформата
* Всеки да може да се регистрира с популярни социални платформи \(Google, Facebook\)
* Да има възможност дарителите да останат анонимни при желание
* Всички работни пароли трябва да се намират извън кода на проекта

### Разработка от доброволци

* Да има добра документация
  * на архитектурата
  * на връзките между компонентите
  * на API ниво чрез swagger или додобни инструменти
* Да се използват разпространени технологии и работни рамки \(frameworks\)
* Да се използва език със стриктно типизиране
* Да поддържат бърза разработка на стандартни функционалности
* Да може да се стартира целият проект локално без голямо натоварване и сложност
* Да има безопазни за разработка среди \(dev, staging\)
* Да има автоматично
  * пускане на тестове при създаване на pull request
  * създаване на контейнери
  * качване на кода към различните среди

### **Споделеност**

* При възможност да се преизползват общи
  * правила за валидация на frontend и backend
  * типове на данните
  * константни стойности
  * преводи
  * функционалности
* При възможност да се използва един и същи език за програмиране

### Сигурност

* Да се избегнат директни външни промени по базата данни
* Всеки потребител да има достъп само до своите данни
* Да има автоматични тестове, които потвърждават липсата на изтичане на данни
* Всички заявки за включване на код да минават през код ревю процес

### Одит и прозрачност

* Всяка промяна на базата данни да се записва
* Всяко качване или изтриване на файл да се записва
* Да има вътрешни статистики за употребата на платформата
* Да се пазят статистиките за определено време
* Да има скалиране на системата за одит при повишаване на трафика

### Хранилище за файлове

* Потребителите да имат достъп само до техните и споделените им файлове
* Потребителите да могат да свалят всичките си файлове при желание \(GDPR\)
* Да има автоматичен бекъп на файловете във външна за платформата среда 

### Бази данни

* Да се използва установена и стабилна база данни
* Да се използват миграции на базата данни
* Да се използват отделни потребители с ограничени права за различни нужди
* Да се използват общи типове на данните за тип на колоните \(domain, type\)
* Да се използва row based security при възможност

### Инфраструктура

* Да бъде подходящо оразмерена спрямо нуждите на платформата
* Да поддържа платформата в добро общо състояние
* Да има добра видимост над натоварването на платформата
* Да разпределя трафика към различните модули
* Да бъде осигурена с контрол на достъпа
* При възможност да поддържа автоматично скалиране при повече трафик

### Възстановяване след бедствие

* Да се съхранява кода за възстановяване на системата \(manifests\)
* Да се извършват автоматични бекъпи на базата данни
* Да има ясна процедура по възстановяване на бекъпи

### Злоупотреба и атаки

* Да се въведе рейт лимити на входящите заявките
* Да се използват системи за превенция на DDoS атаки
* Да има мрежови ограничения за намаляване рисковете от злоупотреби
* Да има валидация на входящите данни на всеки слой

## Възможни варианти

### Фронтенд

* TypeScript
  * [React](https://reactjs.org/)
  * [Next.js](https://nextjs.org/)
* Графична библиотека
  * [MaterialUI](https://material-ui.com/)

### Бекенд

* Основен транспорт на данни
  * GraphQL
    * [Schema](https://graphql.org/learn/schema/)
  * REST
    * [Swagger](https://swagger.io/)
  * [gRPC](https://grpc.io/)
    * [protoc-gen-doc](https://github.com/pseudomuto/protoc-gen-doc)
* Framework
  * Golang
    * [https://gqlgen.com/](https://gqlgen.com/)
    * [https://gofiber.io/](https://gofiber.io/)
  * C\# .NET
    * ??
  * TypeScript
    * [https://nextjs.org/docs/api-routes](https://nextjs.org/docs/api-routes/introduction) \(интегриран с фронтенд\)
    * [https://nestjs.com/](https://nestjs.com/)
    * [https://expressjs.com/](https://expressjs.com/)
  * PHP
    * [https://laravel.com/](https://laravel.com/)
  * DB driven
    * [https://postgrest.org/](https://postgrest.org/en/v8.0/)
* Database
  * Postgres
  * ORM
    * [https://www.prisma.io/](https://www.prisma.io/)
    * [Entity Framework](https://docs.microsoft.com/en-us/ef/) \(C\#\)
  * Migrations
    * [https://flywaydb.org/](https://flywaydb.org/)
    * [Prisma migrate](https://www.prisma.io/docs/concepts/components/prisma-migrate)
    * [https://sqitch.org/](https://sqitch.org/)

### Инфраструктура

* Kubernetes
  * Managed at cloud provider
  * On premises
* Docker-compose \(лоцално\)
  * On premises

## Какво имаме разработено до момента?

До момента успяхме да изградим следната система от микросървиси, свързани с публичният сайт на проекта.

**Модул** **GraphQL Gateway** отговаря за комуникацията между фронтенд и другите сървиси. Неговия публичен транспортен слой е **GraphQL** и функцията на му е да прехвърли заявката към конкретния сървис, който отговаря за нея. Между този модул и отделните сървиси комуникацията е чрез транспортен слой **gRPC**, който осигурява независимост от платформата. ****За момента този модул **няма изградени възможности за валидация на JWT** и оторизация на заявките.

**Модулът Контакти** в момента работи с REST заявки, с идеята и той да премине към gRPC. Модул кампании е разработен на C\#/.NET и в момента 

За **Модул Плащания** разработката е стигнала само до модел на базата данни, планът за този модул е да бъде реализиран на **PHP**

В момента разработката на **Модул Идентичност** въобще **не е започната** и **не е избран език** за изпълнението му.

**Не е започната интеграцията** с брокера на събития, но има идея за това да се ползва **Kafka**

#### Планирана функционалност

![](../.gitbook/assets/technical-landscape-module-communication-bg-.jpg)

#### Реализирана функционалност

![](../.gitbook/assets/technical-landscape-module-communication-done-.jpg)

## Защо се наложи да променим архитектурата?

### Затруднение да намерим доброволци

В началото на проекта, това което се знаеше е, че има **700 записали се доброволци** в над 10 основни направления и **опит в множество програмни езици.** Архитектурата беше планирана да бъде изградена от хора с познания в различни технологии, като за тази цел всеки трябва да се чувства комфортно да пише на позната технология. Беше направена разбивка и проучване за **най-желани технологии**, което определи и функционалните екипи.

След като мина известно време стана ясно, че активните доброволци, **които наистина са готови да се включат** в проекта с действие **са десетки, а не стотици**. Това доведе до много бавен прогрес по проекта и **увеличи изискванията за devops помощ** при създаване на нужната комуникационна инфраструктура за микросървиси.

### Консултации с хора с опит

След като се консултирахме с **опитни архитекти** от българското ИТ общество успяхме да установим, че с **текущата архитектура решаваме проблем, който все още нямаме**. Предвид, че системата няма работна MVP версия, **това трябва да ни е целта**. Първоначалната архитектура беше създадена да се справи с хиляди заявки в секунда, но това решение е изпреварило времето си. 

### Нямаше ясни технически изисквания

Без конркетни изисквания е **трудно да се определи дали е постигнат резултата** и дали решението съответства на визията на платформата. Изборът на технологии беше направен **спрямо желанията на доброволците**, вместо нуждите на платформата.

### Да се използва една технология

При използването на **три и повече технологии** в един проект се променя много изискването на опита на доброволците. Това е плюс от една страна, че повече хора ще могат да се включат, но от друга страна хората са ограничени до включване **само в технологията, която им е позната**. Като сведем разработката до една технология, може би ще намалим броя на доброволците, но хората, които се включат ще се чувстват по-комфортно да доставят повече функционалности.

### Преизползване на код

При използването на една технология, можем да преизползваме голяма част от вече разработения код и това **да намали времето за разработка**.

### Да може всеки да работи локално

За по-бързо включване в проекта на доброволци е подходящо цялата система да може да бъде стартирана в локална среда, без връзка към външни компоненти. Това дава **повече сигурност** на неуверените доброволци, **че** **няма да "счупят нещо"**. При архитектурно решение с множество микросървиси на различни технологии **изискванията за локалната среда се повишават** значително. Разбира се не изключваме варианта **за работа "на парче"**, но така цялостната интеграция на компонентите **би изисквала повече време**.

## Решението

### Да се използва общ език

Технологията, с която най-много хора от основния екип имат опит е **TypeScript**. След дискусии се стигна до заключението, че ако се спрем на един език ще имаме най-бърз прогрес по проекта, най-много код ще се преизползва и най-ефективно ще продължим напред.

### Да се използва една технология

От възможните работни рамки базирани на TypeScript, най-подходяща се оказа [**NestJS**](https://nestjs.com/)\*\*\*\*

Бяха взети предвид следните съображения:

* общност на проекта \([https://github.com/nestjs/nest](https://github.com/nestjs/nest) 40k ⭐\)
* документация
* примерни проекти
* транспортни слоеве
  * [REST](https://docs.nestjs.com/controllers)
  * [GraphQL](https://docs.nestjs.com/graphql/quick-start)
  * [Websocket](https://docs.nestjs.com/websockets/gateways)
* включени стандартни компоненти
  * [модулярност](https://docs.nestjs.com/modules)
  * сигурност
    * [валидация](https://docs.nestjs.com/techniques/validation)
    * [аутентикация](https://docs.nestjs.com/security/authentication)
    * [оторизация](https://docs.nestjs.com/security/authorization)
    * [rate limiting](https://docs.nestjs.com/security/rate-limiting)
  * [кеширане](https://docs.nestjs.com/techniques/caching)
  * [автоматични тестове](https://docs.nestjs.com/fundamentals/testing)
  * oбработка на грешки
* външни интеграции, които можем да използваме
  * [Prisma](https://docs.nestjs.com/recipes/prisma)
  * [Swagger](https://docs.nestjs.com/openapi/introduction)
  * [Keycloak](https://github.com/ferrerojosh/nest-keycloak-connect)
  * [Stripe](https://github.com/golevelup/nestjs/tree/master/packages/stripe)
  * [Sentry](https://github.com/ntegral/nestjs-sentry)

### Да се използва една база данни

Използвайки **една база** вместо отделни и **една схема** вместо отделни ние даваме възможност да се изгради начална работеща версия на приложението без излишни технически препятствия. Когато се намери подходящ сценарии, който изисква отделни схеми и бази ще бъде имплементиран.

Подходящо решение, което да ни позволи бързодействие и еднотипни промени по базата е [Prisma](https://prisma.io/). 

Чрез това решение ние:

* ще намалим времето за разписване на схемата на базата
* ще се подсигурим, че връзките между обектите са в синхрон
* ще генерираме типове за обектите в базата автоматично
* ще генерираме миграционни скриптове автоматично

Разбира се, това решение както и всички останали би имало недостатъци

* има [познати ограничения](https://www.prisma.io/docs/about/prisma/limitations), с които сме наясно
* не можем да използваме абсолютно всичко, което [базата поддържа](https://www.prisma.io/docs/concepts/components/prisma-migrate/prisma-migrate-limitations-issues)



## 

